### BJ1976 ì—¬í–‰ê°€ì

[ğŸ“ë¬¸ì œë³´ê¸°](https://www.acmicpc.net/problem/1976)

---

#### ë°©ë²• 2ê°€ì§€

1. BFS
   - ì‹œê°„ : 228ms
2. Union-Find
   - ì‹œê°„ : 92ms

---

#### ë°©ë²• 1_ BFS í’€ì´

1. ê°’ ì…ë ¥ ë°›ê¸°

   - `N` : ë„ì‹œì˜ ìˆ˜
   - `M` : ì—¬í–‰ ê³„íš ë„ì‹œë“¤ ìˆ˜
   - `map` : ì´ë™ ê°€ëŠ¥í•œ ë„ì‹œ ì—¬ë¶€(boolean[N\][N\])

2. BFSë¡œ í˜„ì¬ ì—¬í–‰ì§€(`now`) â†’ ë‹¤ìŒ ì—¬í–‰ì§€(`next`) ì´ë™ ê°€ëŠ¥í•œì§€ íŒë³„

   1. queì— í˜„ì¬ ì—¬í–‰ì§€ë¥¼ ë‹´ê³ , ë°©ë¬¸ ì²˜ë¦¬ë¥¼ í•¨

   2. queê°€ ë¹„ì–´ìˆì„ ë•Œê¹Œì§€ ë°˜ë³µí•˜ë©°, ì´ë™í•  ìˆ˜ ìˆê³  ë°©ë¬¸í•˜ì§€ ì•Šì€ ì—¬í–‰ì§€ë¼ë©´ queì— ë‹´ê³ , ë°©ë¬¸ ì²˜ë¦¬í•¨.

   3. ë°˜ë³µí•˜ë©´ì„œ que.poll() ê°’ì´ `next`ê°’ê³¼ ê°™ê²Œ ë˜ë©´ `true`ë¥¼ ë¦¬í„´

   4. ë°˜ë³µì´ ëë‚˜ë„ ë‹¤ìŒ ì—¬í–‰ì§€ë¡œ ê°ˆ ìˆ˜ ì—†ë‹¤ë©´, `false`ì„ ë¦¬í„´

3. ì—¬í–‰ ê³„íšëŒ€ë¡œ ëª¨ë‘ ë°©ë¬¸ ê°€ëŠ¥í•˜ë‹¤ë©´ `YES`ë¥¼ ì¶œë ¥, ê°ˆ ìˆ˜ ì—†ë‹¤ë©´ `NO` ì¶œë ¥í•œë‹¤.

---

#### ë°©ë²• 1_BFS ì½”ë“œ

```java
import java.io.*;
import java.util.*;

/*
 * ê·¸ë˜í”„
 * BFS
 */

public class B1976ì—¬í–‰ê°€ì_1 {
  static int N, M;
  static boolean[][] map;

  public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    N = Integer.parseInt(br.readLine());
    M = Integer.parseInt(br.readLine());
    map = new boolean[N][N];

    // ë°©ë¬¸ ê°€ëŠ¥í•œ ë„ì‹œ ì…ë ¥ ë°›ê¸°
    for (int i = 0; i < N; i++) {
      String str = br.readLine();
      for (int j = 0; j < N; j++) {
        if ((str.charAt(2 * j) - '0') == 1) {
          map[i][j] = true;
        }
      }
    }

    // ì—¬í–‰ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
    boolean check = true;
    StringTokenizer st = new StringTokenizer(br.readLine());
    int now = Integer.parseInt(st.nextToken()) - 1;
    for (int i = 1; i < M; i++) {
      int next = Integer.parseInt(st.nextToken()) - 1;
      if (!BFS(now, next)) {
        check = false;
        break;
      }
      now = next;
    }

    System.out.print(check ? "YES" : "NO");
  }

  private static boolean BFS(int now, int next) {
    if (now == next)
      return true;

    Queue<Integer> que = new LinkedList<>();
    boolean[] visited = new boolean[N];
    que.add(now);
    visited[now] = true;

    while (!que.isEmpty()) {
      int city = que.poll();
      for (int i = 0; i < N; i++) {
        if (i == next && map[city][i])
          return true;

        if (map[city][i] && !visited[i]) {
          que.add(i);
          visited[i] = true;
        }
      }
    }

    return false;
  }
}

```

---

#### ë°©ë²•2_Union-Find í’€ì´

> ğŸ” ì´ë¡  ì°¸ê³  : [ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ(Union-Find)](https://ip99202.github.io/posts/%EC%9C%A0%EB%8B%88%EC%98%A8-%ED%8C%8C%EC%9D%B8%EB%93%9C(Union-Find)/)
>
> Union í•¨ìˆ˜ : ë…¸ë“œë¥¼ í•©ì¹¨  
> Find í•¨ìˆ˜ : ë£¨íŠ¸ ë…¸ë“œ ì°¾ê¸°

1. ê°’ ì…ë ¥ ë°›ê¸°
   - `N` : ë„ì‹œì˜ ìˆ˜
   - `M` : ì—¬í–‰ ê³„íš ë„ì‹œë“¤ ìˆ˜
   - `parent` : ê° ë„ì‹œì—ì„œ ìµœìƒìœ„ ë…¸ë“œ(int[N\])
2.  ë°©ë¬¸ ê°€ëŠ¥í•œ ë„ì‹œ ì…ë ¥ ë°›ê¸°(`union` ì—°ì‚°) : _ex) aì™€ bë„ì‹œê°€ ì—°ê²°ë˜ì–´ ìˆë‹¤ë©´_
   1. a ë„ì‹œì™€ b ë„ì‹œì˜ ìµœìƒìœ„ ë…¸ë“œ í™•ì¸í•˜ê¸°(`find` ì—°ì‚°)
      1. ë‚˜ì˜ ìµœìƒìœ„ ë…¸ë“œê°€ ë‚´ ìì‹ ì´ë¼ë©´ í•´ë‹¹ ê°’ ë¦¬í„´
      2. ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ë‚´ ìµœìƒìœ„ ë…¸ë“œ ê°’ ë¦¬í„´ 
   2. ë‘ ë„ì‹œì˜ ìµœìƒìœ„ ë…¸ë“œê°€ ê°™ë‹¤ë©´ ì´ë¯¸ ì—°ê²°ë˜ì–´ ìˆëŠ” ë…¸ë“œì´ë¯€ë¡œ ë¦¬í„´
   3. aì™€ bê°€ ì—°ê²°ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ê°™ì€ ìµœìƒìœ„ ë…¸ë“œë¥¼ ê°€ë¦¬í‚¤ë„ë¡ bë„ì‹œì— a ë„ì‹œì˜ ìµœìƒìœ„ ë…¸ë“œ ì €ì¥í•œë‹¤.
3. `find` í•¨ìˆ˜ë¡œ í˜„ì¬ ì—¬í–‰ì§€(`now`) â†’ ë‹¤ìŒ ì—¬í–‰ì§€(`next`) ì´ë™ ê°€ëŠ¥í•œì§€ íŒë³„
   - í˜„ì¬ ì—¬í–‰ì§€(`now`)ì˜ ìµœìƒìœ„ ë…¸ë“œ ê°’ê³¼ ë‹¤ìŒ ì—¬í–‰ì§€(`next`)ì˜ ìµœìƒìœ„ ë…¸ë“œê°€ ê°™ë‹¤ë©´ ì´ë™í•  ìˆ˜ ìˆìŒ
   - í˜„ì¬ ì—¬í–‰ì§€(`now`)ì˜ ìµœìƒìœ„ ë…¸ë“œ ê°’ê³¼ ë‹¤ìŒ ì—¬í–‰ì§€(`next`)ì˜ ìµœìƒìœ„ ë…¸ë“œê°€ ë‹¤ë¥´ë‹¤ë©´ ì´ë™í•  ìˆ˜ ì—†ìŒ
4. ì—¬í–‰ ê³„íšëŒ€ë¡œ ëª¨ë‘ ë°©ë¬¸ ê°€ëŠ¥í•˜ë‹¤ë©´ `YES`ë¥¼ ì¶œë ¥, ê°ˆ ìˆ˜ ì—†ë‹¤ë©´ `NO` ì¶œë ¥í•œë‹¤.

---

#### ë°©ë²•2_Union-Find ì½”ë“œ

```java
import java.io.*;
import java.util.*;

/*
 * ê·¸ë˜í”„ 
 * ìœ ë‹ˆì˜¨ íŒŒì¸ë“œ
 * union ì—°ì‚°
 */

public class B1976ì—¬í–‰ê°€ì_2 {
  static int N, M;
  static int[] parent;

  public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    N = Integer.parseInt(br.readLine());
    M = Integer.parseInt(br.readLine());
    parent = new int[N];
    for (int i = 0; i < N; i++) {
      parent[i] = i;
    }

    // ë°©ë¬¸ ê°€ëŠ¥í•œ ë„ì‹œ ì…ë ¥ ë°›ê¸°
    for (int i = 0; i < N; i++) {
      String str = br.readLine();
      for (int j = 0; j < N; j++) {
        if ((str.charAt(2 * j) - '0') == 1) {
          union(i, j);
        }
      }
    }

    // ì—¬í–‰ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
    boolean check = true;
    StringTokenizer st = new StringTokenizer(br.readLine());
    int now = Integer.parseInt(st.nextToken()) - 1;
    for (int i = 1; i < M; i++) {
      int next = Integer.parseInt(st.nextToken()) - 1;
      if (find(now) != find(next)) {
        check = false;
        break;
      }
      now = next;
    }

    System.out.print(check ? "YES" : "NO");
  }

  private static int find(int x) {
    if (parent[x] == x) // ë°°ì—´ ì¸ë±ìŠ¤ì™€ ê°’ì´ ê°™ë‹¤ë©´ í•´ë‹¹ ê°’ ë¦¬í„´
      return x;
    return parent[x] = find(parent[x]); // ë°°ì—´ì˜ ê°’ì„ ì¸ë±ìŠ¤ë¡œ ê°–ëŠ” ê°’ ë¦¬í„´
  }

  private static void union(int x, int y) {
    x = find(x); // ìµœìƒìœ„ ë…¸ë“œ ì°¾ê¸°
    y = find(y);
    if (x == y)
      return; // ê°™ì€ ì§‘í•©(ì´ë¯¸ ì—°ê²° ë˜ì–´ ìˆìŒ)
    parent[y] = x;
  }
}
```
