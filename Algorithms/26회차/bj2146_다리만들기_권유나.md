## [ğŸ±](https://www.acmicpc.net/problem/2146) [bj2146] ë‹¤ë¦¬ ë§Œë“¤ê¸°

> **ì†Œìš” ì‹œê°„: 19ë¶„<br>
> ë©”ëª¨ë¦¬: 135440KB<br>
> ì‹œê°„: 228ms**
## ë¬¸ì œ ì ‘ê·¼
- ì˜¤ëœë§Œì— bfsë¡œ ë¬¸ì œ í’€ê¸°!

## ë¬¸ì œ í’€ì´
1. `map`ì— ì§€ë„ë¥¼ ì…ë ¥ë°›ëŠ”ë‹¤. ì„¬ì´ë©´ 1, ë°”ë‹¤ë©´ 0
2. `findIsland`: bfsë¥¼ ì´ìš©í•´ ì„¬ì„ ê·¸ë£¹í™”í•œë‹¤. (ì„¬ì˜ ë²ˆí˜¸ëŠ” 2ë¶€í„° ì‹œì‘)
3. `makeBridge`: bfsë¥¼ ì´ìš©í•´ ì„¬ì˜ í•´ë‹¹ ìœ„ì¹˜`(i,j)`ì—ì„œ ë‹¤ë¥¸ ì„¬ê¹Œì§€ì˜ ìµœì†Œ ë‹¤ë¦¬ê¸¸ì´ë¥¼ í™•ì¸í•˜ê³  `min`ì— ìµœì†Ÿê°’ì„ ê°±ì‹ í•œë‹¤.
4. `min`ì„ ì¶œë ¥í•œë‹¤.
## ì „ì²´ ì½”ë“œ
```java
import java.io.BufferedReader;  
import java.io.InputStreamReader;  
import java.util.LinkedList;  
import java.util.Queue;  
import java.util.StringTokenizer;  
  
public class Main {  
    static final int[] di = new int[]{-1, 0, 1, 0};  
    static final int[] dj = new int[]{0, 1, 0, -1};  
    static int[][] map;  
    static int N, min;  
  
    public static void main(String[] args) throws Exception {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        N = Integer.parseInt(br.readLine().trim());  
        map = new int[N][N];  
        min = Integer.MAX_VALUE;  
        for (int i = 0; i < N; i++) {  
            StringTokenizer st = new StringTokenizer(br.readLine(), " ");  
            for (int j = 0; j < N; j++) {  
                map[i][j] = st.nextToken().charAt(0) - '0';  
            }  
        }  
        findIsland();  
        makeBridge();  
  
        System.out.println(min);  
    }  
  
    static void findIsland() {  
        int num = 2;  
        for (int i = 0; i < N; i++) {  
            for (int j = 0; j < N; j++) {  
                if (map[i][j] == 1) {  
                    bfsFindIsland(i, j, num++);  
                }  
            }  
        }  
    }  
  
    static void bfsFindIsland(int i, int j, int num) {  
        Queue<int[]> queue = new LinkedList<>();  
        map[i][j] = num;  
        queue.offer(new int[]{i, j});  
        while (!queue.isEmpty()) {  
            int[] node = queue.poll();  
            for (int z = 0; z < 4; z++) {  
                int ni = node[0] + di[z];  
                int nj = node[1] + dj[z];  
                if (check(ni, nj) && map[ni][nj] == 1) {  
                    map[ni][nj] = num;  
                    queue.offer(new int[]{ni, nj});  
                }  
            }  
        }  
    }  
  
    static void makeBridge() {  
        for (int i = 0; i < N; i++) {  
            for (int j = 0; j < N; j++) {  
                if (map[i][j] > 1) {  
                    bfsMakeBridge(i, j);  
                }  
            }  
        }  
    }  
  
    static void bfsMakeBridge(int i, int j) {  
        boolean[][] visited = new boolean[N][N];  
        Queue<int[]> queue = new LinkedList<>();  
  
        visited[i][j] = true;  
        queue.offer(new int[]{i, j, 0});  
  
        while (!queue.isEmpty()) {  
            int[] node = queue.poll();  
            if (min <= node[2]) return;  
            for (int z = 0; z < 4; z++) {  
                int ni = node[0] + di[z];  
                int nj = node[1] + dj[z];  
                if (check(ni, nj) && !visited[ni][nj]) {  
                    if (map[ni][nj] == 0) {  
                        visited[ni][nj] = true;  
                        queue.offer(new int[]{ni, nj, node[2] + 1});  
                    } else if (map[ni][nj] != map[i][j]) {  
                        min = node[2];  
                    }  
                }  
            }  
        }  
    }  
  
    static boolean check(int i, int j) {  
        return 0 <= i && i < N && 0 <= j && j < N;  
    }  
  
}
```
