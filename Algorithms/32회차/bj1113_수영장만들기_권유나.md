## [ğŸŒŠ](https://www.acmicpc.net/problem/1113) [bj1113] ìˆ˜ì˜ì¥ ë§Œë“¤ê¸°

> **ì†Œìš” ì‹œê°„: 70ë¶„<br>
> ë©”ëª¨ë¦¬: 122288KB<br>
> ì‹œê°„: 364ms**

## ë¬¸ì œ ì ‘ê·¼
- ìˆ˜ì˜ì¥ ì•ˆì—ì„œ `h`ë¯¸ë§Œì˜ ê°’ë“¤ì´ `h`ì´ìƒì˜ ê°’ë“¤ì— ë‘˜ëŸ¬ì‹¸ì—¬ ìˆëŠ”ì§€ í™•ì¸í•˜ë©° ë¬¸ì œë¥¼ í’€ì—ˆë‹¤.
## ë¬¸ì œ í’€ì´
1. `makePool()`: ìˆ˜ì˜ì¥ì˜ ë†’ì´`h`ë¥¼ 9ë¶€í„° ë‚´ë¦¼ì°¨ìˆœìœ¼ë¡œ í™•ì¸
	1. ì…ë ¥ëœ ìˆ˜ì˜ì¥ì—ì„œ `h`ì— í•´ë‹¹í•˜ëŠ” ìœ„ì¹˜ë¥¼ `visited`ë¡œ ë°©ë¬¸ì²˜ë¦¬ì‹œí‚¨ë‹¤. 
	2. `h`ë¥¼ ëª¨ë‘ ë°©ë¬¸ ì²˜ë¦¬ ì‹œí‚¨ í›„ì— `checkPool(h)`í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œë‹¤.
2. `checkPool(h)`: ìˆ˜ì˜ì¥ì˜ ë†’ì´ `h` ì£¼ë³€ì— `h` ë¯¸ë§Œì˜ ê°’ì´ ìˆëŠ”ì§€ í™•ì¸
	1. ìˆ˜ì˜ì¥ì´ `h`ì¸ ê²½ìš°ë¥¼ ì°¾ê³ , ìƒí•˜ì¢Œìš° ì¤‘ `h` ë¯¸ë§Œì˜ ë†’ì´ë©´ì„œ ë°©ë¬¸ì²˜ë¦¬ê°€ ë˜ì§€ ì•Šì€ ìœ„ì¹˜ë¥¼ ì°¾ì•„ `bfs(..)`í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•œë‹¤.
3. `bfs(i, j, h)`: ìˆ˜ì˜ì¥ì˜ ë†’ì´ `h` ì´ìƒì˜ ê°’ë“¤ë¡œ ë‘˜ëŸ¬ì‹¸ì—¬ ìˆëŠ”ì§€ í™•ì¸
	1. `i`,`j`ìœ„ì¹˜ì˜ ê°’ì„ ì‹œì‘ìœ¼ë¡œ bfsë¡œ íƒìƒ‰í•œë‹¤. 
	2. ì‚¬ë°©íƒìƒ‰í•˜ë©° `h`ë¯¸ë§Œì˜ ë†’ì´ë¥¼ ê°€ì¡Œê³ , ë°©ë¬¸ì²˜ë¦¬ë¥¼ í•˜ì§€ ì•Šì€ ìœ„ì¹˜ì— ì ‘ê·¼í•œë‹¤.
		1. bfsì— ëŒ€í•œ ë°©ë¬¸ì²˜ë¦¬ëŠ” `tmp_visited`ì— í‘œì‹œí•œë‹¤.
		2. í ì•ˆì— ë„£ì„ë•Œ ë°©ë¬¸ì²˜ë¦¬ í•˜ê³ , `cnt`ì— `h`ì™€ í˜„ì¬ ìˆ˜ì˜ì¥ ë†’ì´ì˜ ì°¨ë¥¼ ë”í•œë‹¤.
	3. ë§Œì•½ ì‚¬ë°©íƒìƒ‰ì„ í–ˆì„ë•Œ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¬ë‹¤ë©´ `h`ì´ìƒì˜ ë†’ì´ì— ë‘˜ëŸ¬ ì‹¸ì¼ ìˆ˜ ì—†ìœ¼ë¯€ë¡œ í•¨ìˆ˜ë¥¼ ì¢…ë£Œí•œë‹¤. 
	4. bfsê°€ ëë‚˜ë©´, `tmp_visited`ì— í‘œì‹œëœ ê²ƒë“¤ì„ `visited`ì— í‘œì‹œí•œë‹¤.
	5. `answer`ì— `cnt`ë¥¼ ë”í•œë‹¤.

## ì „ì²´ ì½”ë“œ
```java
import java.io.BufferedReader;  
import java.io.InputStreamReader;  
import java.util.LinkedList;  
import java.util.Queue;  
  
public class Main_1113 {  
    static final int[] di = {-1, 0, 1, 0};  
    static final int[] dj = {0, 1, 0, -1};  
    static int N, M, answer;  
    static int[][] map;  
    static int[] counts;  
    static boolean[][] visited;  
  
    public static void main(String[] args) throws Exception {  
        init();  
        makePool();  
        System.out.println(answer);  
    }  
  
    static void init() throws Exception {  
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));  
        String input = br.readLine();  
  
        N = Integer.parseInt(input.substring(0, input.indexOf(' ')));  
        M = Integer.parseInt(input.substring(input.indexOf(' ') + 1));  
        map = new int[N][M];  
        visited = new boolean[N][M];  
        counts = new int[10];  
        for (int n = 0; n < N; n++) {  
            input = br.readLine();  
            for (int m = 0; m < M; m++) {  
                map[n][m] = input.charAt(m) - '0';  
                counts[map[n][m]]++;  
            }  
        }  
  
        answer = 0;  
    }  
  
    static void makePool() {  
        for (int h = 9; 0 < h; h--) {  
            if (0 < counts[h]) {  
                next:  
                for (int n = 0; n < N; n++) {  
                    for (int m = 0; m < M; m++) {  
                        if (map[n][m] == h) {  
                            visited[n][m] = true;  
                            if (--counts[h] == 0) break next;  
                        }  
                    }  
                }  
                checkPool(h);  
            }  
        }  
  
  
    }  
  
    static void checkPool(int h) {  
        for (int n = 0; n < N; n++) {  
            for (int m = 0; m < M; m++) {  
                if (map[n][m] == h) {  
                    for (int z = 0; z < 4; z++) {  
                        int ni = n + di[z];  
                        int nj = m + dj[z];  
                        if (check(ni, nj) && !visited[ni][nj]) {  
                            bfs(ni, nj, h);  
                        }  
                    }  
                }  
            }  
        }  
    }  
  
    static void bfs(int i, int j, int h) {  
        int cnt = h - map[i][j];  
        Queue<int[]> queue = new LinkedList<>();  
        boolean[][] tmp_visited = new boolean[N][M];  
        queue.add(new int[]{i, j});  
        tmp_visited[i][j] = true;  
  
        next:  
        while (!queue.isEmpty()) {  
            int[] node = queue.poll();  
  
            for (int z = 0; z < 4; z++) {  
                int ni = node[0] + di[z];  
                int nj = node[1] + dj[z];  
                if (!check(ni, nj)) {  
                    return;  
                } else if (!visited[ni][nj] && !tmp_visited[ni][nj]) {  
                    queue.add(new int[]{ni, nj});  
                    tmp_visited[ni][nj] = true;  
                    cnt += h - map[ni][nj];  
                }  
            }  
        }  
        for (int n = 0; n < N; n++) {  
            for (int m = 0; m < M; m++) {  
                if (tmp_visited[n][m]) {  
                    visited[n][m] = true;  
                }  
            }  
        }  
        answer += cnt;  
    }  
  
    static boolean check(int i, int j) {  
        return 0 <= i && i < N && 0 <= j && j < M;  
    }  
}
```
