# [ğŸ](https://www.acmicpc.net/problem/5547) [bj5547] ì¼ë£¨ë¯¸ë„¤ì´ì…˜

> **ì†Œìš” ì‹œê°„: 28ë¶„<br>
> ë©”ëª¨ë¦¬: 12112KB<br>
> ì‹œê°„: 88ms**

## ë¬¸ì œ ì ‘ê·¼

* BFSë¡œ ì™¸ë¶€ë¥¼ ì²´í¬í•˜ê³ , ë²½ì„ ì¹´ìš´íŒ…í•œë‹¤.
* ë¬¸ì œì—ì„œëŠ” í–‰ì—´ì´ ë°”ë€ì±„ ì„¤ëª…ë˜ì–´ìˆì§€ë§Œ, ë°”ê¾¸ì§€ ì•Šê³  ë¬¸ì œë¥¼ í‘¼ë‹¤. (y,x)

## ë¬¸ì œ í’€ì´

1. `map`ì— í¬ê¸°ë¥¼ ìƒí•˜ì¢Œìš°ì— 1ì”© ëŠ˜ë ¤ [H+2]{W+2]ë§Œí¼ ì´ˆê¸°í™”í•œë‹¤.
2. `map`ì—ì„œ ì§‘ì€ 1ë¡œ ì²´í¬í•œë‹¤.
3. í–‰(i)ì´ ì§ìˆ˜, í™€ìˆ˜ì¼ë•Œ ì£¼ë³€ì— íƒìƒ‰í•´ì•¼í•˜ëŠ” ìœ„ì¹˜ê°€ ë°”ë€Œë¯€ë¡œ ì§ìˆ˜ëŠ” 0, í™€ìˆ˜ëŠ” 1ë¡œ 2ì°¨ì› ë°°ì—´ `di`, `dj`ë¥¼ ìƒì„±í•œë‹¤.
4. (0,0)ì€ ë¬´ì¡°ê±´ ì™¸ë¶€ì´ë¯€ë¡œ (0,0)ì„ íì— ë„£ê³  bfsë¥¼ ëŒë¦°ë‹¤.
5. ì£¼ë³€ì„ íƒìƒ‰í• ë•Œ, `map` ë²”ìœ„ ì•ˆì— ìˆìœ¼ë©´ì„œ +
   1. `map[ni][nj]`ê°€ 0ì´ë©´ ì™¸ë¶€ë¼ëŠ” ì˜ë¯¸ë¡œ ê°’ì„ 2ë¡œ ë³€ê²½í›„ íì— ë„£ëŠ”ë‹¤.
   2. `map[ni][nj]`ê°€ 1ì´ë©´ ì™¸ë¶€ì— ë‹¿ì€ ë²½ì´ë¯€ë¡œ `answer`ë¥¼ 1 ì˜¬ë¦°ë‹¤.
6. bfsê°€ ëë‚˜ë©´ `answer`ë¥¼ ì¶œë ¥í•œë‹¤.

## ì „ì²´ ì½”ë“œ

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.LinkedList;
import java.util.Queue;

public class Main_5547 {

    public static void main(String[] args) throws Exception {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String input = br.readLine();
        int W = Integer.parseInt(input.substring(0, input.indexOf(" ")));
        int H = Integer.parseInt(input.substring(input.indexOf(" ") + 1));
        int[][] map = new int[H + 2][W + 2];

        for (int i = 1; i <= H; i++) {
            input = br.readLine();
            for (int j = 0; j < W; j++) {
                if (input.charAt(j + j) == '1') map[i][j + 1] = 1;
            }
        }

        Queue<int[]> queue = new LinkedList<>();
        map[0][0] = 2;
        queue.offer(new int[]{0, 0});

        int[][] di = {{-1, -1, 0, 1, 1, 0}, {-1, -1, 0, 1, 1, 0}};
        int[][] dj = {{-1, 0, 1, 0, -1, -1}, {0, 1, 1, 1, 0, -1}};
        int answer = 0;

        while (!queue.isEmpty()) {
            int[] node = queue.poll();
            int idx = node[0] % 2;

            for (int z = 0; z < 6; z++) {
                int ni = node[0] + di[idx][z];
                int nj = node[1] + dj[idx][z];
                if (0 <= ni && ni <= H + 1 && 0 <= nj && nj <= W + 1) {
                    if (map[ni][nj] == 0) {
                        map[ni][nj] = 2;
                        queue.offer(new int[]{ni, nj});
                    } else if (map[ni][nj] == 1) {
                        answer++;
                    }

                }
            }
        }

        System.out.println(answer);

    }

}

```
