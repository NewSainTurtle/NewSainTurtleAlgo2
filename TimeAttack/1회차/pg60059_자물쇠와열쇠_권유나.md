## [ğŸ”](https://school.programmers.co.kr/learn/courses/30/lessons/60059) [pg60059] ìë¬¼ì‡ ì™€ ì—´ì‡ 

> **ì†Œìš” ì‹œê°„: 85ë¶„<br>
> ë©”ëª¨ë¦¬: --KB<br>
> ì‹œê°„: --ms**

## ë¬¸ì œ ì ‘ê·¼

- í° ë³´ë“œíŒì„ ë§Œë“¤ê³  ì¤‘ì•™ì— ìë¬¼ì‡ ë¥¼ ì €ì¥í•œë‹¤. í›„ì— ìŠ¬ë¼ì´ë”© ìœˆë„ìš°ë¥¼ ì´ìš©í•´ í‚¤ë¥¼ ì—´ì‡ ì™€ í‚¤ë¥¼ ë§ì¶°ë³¸ë‹¤(XOR).

## ì „ì²´ ì½”ë“œ

```java
import java.util.*;

class Solution_60059 {

    boolean[][] map;
    boolean[][] global_key;
    int  N, M, T;
    int blank;

    public boolean solution(int[][] key, int[][] lock) {
        init(key, lock);
        if(blank == 0){
            return true;
        }
        boolean answer = false;
        for(int z=0; z<4; z++){
            if(check()){
                answer = true;
                break;
            }else if(z < 3) {
                rotate();
            }
        }

        return answer;
    }

    boolean check(){

        for(int big_i=0; big_i<=T-M; big_i++){
            next: for(int big_j=0; big_j<=T-M; big_j++){
                int cnt=0;
                for(int y=0; y<M; y++){
                    for(int x=0; x<M; x++){
                        if(big_j+x < M-1){
                            continue;
                        }else if(big_i+y < M-1 || big_i+y > N+M-2 || big_j+x > N+M-2){
                            break;
                        }else if(!(map[big_i+y][big_j+x]^global_key[y][x])){
                            continue next;
                        }else if(global_key[y][x]){
                            cnt++;
                        }
                    }
                }
                if(blank==cnt) return true;
            }
        }

        return false;
    }

    void rotate(){
        boolean[][] tmp = new boolean [M][M];
        for(int i=0; i<M; i++){
            for(int j=0; j<M; j++){
                tmp[j][M-1-i] = global_key[i][j];
            }
        }
        global_key = tmp;
    }

    void init(int[][] key, int[][] lock){
        N = lock.length;
        M = key.length;
        T = N+M+M-2;
        global_key = new boolean[M][M];
        map = new boolean[T][T];
        blank = 0;

        for(int i=0; i<M; i++){
            for(int j=0; j<M; j++){
                global_key[i][j] = key[i][j]==1;
            }
        }

        for(int i=0; i<N; i++){
            for(int j=0; j<N; j++){
                if(lock[i][j]==1){
                    map[M-1+i][M-1+j] = true;
                }else{
                    blank++;
                }
            }
        }
    }
}
```
