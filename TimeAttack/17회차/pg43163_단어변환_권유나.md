## [ğŸ¤”](https://school.programmers.co.kr/learn/courses/30/lessons/43163) [pg43163] ë‹¨ì–´ ë³€í™˜

> **ì†Œìš” ì‹œê°„: 30ë¶„<br>
> ë©”ëª¨ë¦¬: --KB<br>
> ì‹œê°„: --ms**
## ë¬¸ì œ ì ‘ê·¼
- ìµœì†Œ ë‹¨ê³„ë¥¼ êµ¬í•˜ëŠ” ë¬¸ì œì˜€ê¸° ë•Œë¬¸ì— bfsë¡œ ë¬¸ì œë¥¼ í’€ì—ˆë‹¤.
- ì²˜ìŒì—ëŠ” ë‘ ë‹¨ì–´ê°€ í•˜ë‚˜ë§Œ ì°¨ì´ë‚˜ëŠ” ì§€ í™•ì¸í•˜ëŠ” ê³¼ì •ì„ ë°˜ë³µí•˜ì§€ ì•Šê¸° ìœ„í•´ì„œ ë°°ì—´ì— ë¯¸ë¦¬ ì €ì¥í–ˆëŠ”ë°, ì…ë ¥ ë²”ìœ„ê°€ í¬ì§€ ì•Šì•„ì„œ í•´ë‹¹ ê³¼ì •ì„ ë¹¼ê³  í’€ì–´ë„ ë  ê²ƒ ê°™ì•˜ë‹¤.
- ê·¸ëƒ¥ ë¬¸ì œë¥¼ í’€ì—ˆì„ ë•Œ ì‹œê°„ì´ ë” ë‹¨ì¶•ì´ ë˜ì—ˆë‹¤...ğŸ˜…
## ì „ì²´ ì½”ë“œ
### ğŸ… Map + ë¯¸ë¦¬ ë‹¨ì–´ ë¹„êµ í›„ ì €ì¥
``` java
import java.util.Map;
import java.util.HashMap;
import java.util.Queue;
import java.util.LinkedList;

class Solution {
    Map<Integer, String> dictionary;
    boolean[][] changeList;
    int N, M;
    public int solution(String begin, String target, String[] words) {
        
        int T = 0;
        dictionary = new HashMap<>();
        dictionary.put(0, begin);
        for(String word : words){
            if(!word.equals(begin)) {
                dictionary.put(dictionary.size(), word);
                if (word.equals(target)) T = dictionary.size()-1;
            }
        }
        
        N = begin.length();
        M = dictionary.size();
        changeList = new boolean[M][M];
        for(int i=0; i<M; i++){
            String firstWord = dictionary.get(i);
            for(int j = i+1; j<M; j++){
                changeList[i][j] = changeList[j][i] = checkWord(firstWord, dictionary.get(j));
            }
        }
        
        if(T > 0){ // if(dictionary.containsValue(target)){
            return bfs(T);
        }
        return 0;
    }
    
    boolean checkWord(String firstWord, String secondWord){
        boolean check = false;
        for(int n=0; n < N; n++){
            if(firstWord.charAt(n)!=secondWord.charAt(n)){
                if(check){
                    return false;
                }else{
                    check = true;
                }
            }
        }
        return check;
    }
    
    int bfs(int T){
        Queue<int[]> queue = new LinkedList<>();
        boolean[] visited = new boolean[M];
        
        queue.offer(new int[]{0, 0});
        visited[0] = true;
        
        while(!queue.isEmpty()){
            int[] node = queue.poll();
            
            for(int m=0; m < M; m++){
                if(!visited[m] && changeList[node[0]][m]){
                    if(m==T) return node[1]+1;
                    queue.offer(new int[]{m, node[1]+1});
                    visited[m] = true;
                    
                }
            }   
            
        }
        
        return 0;
    }
}
```

|   |   |
|---|---|
|í…ŒìŠ¤íŠ¸ 1 ã€‰|í†µê³¼ (0.19ms, 77.6MB)|
|í…ŒìŠ¤íŠ¸ 2 ã€‰|í†µê³¼ (0.64ms, 75.1MB)|
|í…ŒìŠ¤íŠ¸ 3 ã€‰|í†µê³¼ (1.02ms, 76.4MB)|
|í…ŒìŠ¤íŠ¸ 4 ã€‰|í†µê³¼ (0.17ms, 66.5MB)|
|í…ŒìŠ¤íŠ¸ 5 ã€‰|í†µê³¼ (0.03ms, 82MB)|

### ğŸ… í•¨ìˆ˜ ì‚¬ìš©X
``` java
import java.util.Map;
import java.util.HashMap;
import java.util.Queue;
import java.util.LinkedList;

class Solution {

    public int solution(String begin, String target, String[] words) {
        
        int B = -1, T = -1;
        for(int w=0; w<words.length; w++){
            if(words[w].equals(begin)) B = w;
            else if(words[w].equals(target)) T = w;
        }
        
        if(T == -1) return 0;
        
        Queue<int[]> queue = new LinkedList<>();
        boolean[] visited = new boolean[words.length];
        
        if(B == -1) {
            for(int w=0; w < words.length; w++){
                int cnt = 0;
                for(int n=0; n<begin.length(); n++){
                    if(words[w].charAt(n)!=begin.charAt(n)) {
                        if(++cnt == 2) break;
                    }
                }
                if(cnt==1){
                    if(w==T) return 1;
                    queue.offer(new int[]{w, 1});
                    visited[w] = true;
                }
            } 
        }else {
            queue.offer(new int[]{B, 0});
            visited[B] = true;
        }
        
        while(!queue.isEmpty()){
            int[] node = queue.poll();
            
            for(int w=0; w < words.length; w++){
                if(!visited[w]){
                    int cnt = 0;
                    for(int n=0; n<begin.length(); n++){
                        if(words[w].charAt(n)!=words[node[0]].charAt(n)) {
                            if(++cnt == 2) break;
                        }
                    }
                    if(cnt==1){
                        if(w==T) return node[1]+1;
                        queue.offer(new int[]{w, node[1]+1});
                        visited[w] = true;
                    }
                    
                }
            }   
            
        }
        
        return 0;
    }
}
```

|   |   |
|---|---|
|í…ŒìŠ¤íŠ¸ 1 ã€‰|í†µê³¼ (0.25ms, 76.6MB)|
|í…ŒìŠ¤íŠ¸ 2 ã€‰|í†µê³¼ (0.21ms, 77MB)|
|í…ŒìŠ¤íŠ¸ 3 ã€‰|í†µê³¼ (0.23ms, 70.2MB)|
|í…ŒìŠ¤íŠ¸ 4 ã€‰|í†µê³¼ (0.08ms, 63.8MB)|
|í…ŒìŠ¤íŠ¸ 5 ã€‰|í†µê³¼ (0.02ms, 69.4MB)|

### ğŸ… ì‚¬ìš©ì ì •ì˜ í´ë˜ìŠ¤ ì‚¬ìš©
``` java
import java.util.Map;
import java.util.HashMap;
import java.util.Queue;
import java.util.LinkedList;

class Solution {

    public int solution(String begin, String target, String[] words) {
        
        Queue<Node> queue = new LinkedList<>();
        boolean[] visited = new boolean[words.length];
        
        queue.offer(new Node(begin, 0));
        
        while(!queue.isEmpty()){
            Node node = queue.poll();
            
            for(int w=0; w < words.length; w++){
                if(!visited[w]){
                    int cnt = 0;
                    for(int n=0; n<begin.length(); n++){
                        if(words[w].charAt(n) != node.word.charAt(n)) {
                            if(++cnt == 2) break;
                        }
                    }
                    if(cnt==1){
                        if(words[w].equals(target)) return node.count+1;
                        queue.offer(new Node(words[w], node.count+1));
                        visited[w] = true;
                    }
                    
                }
            }   
            
        }
        
        return 0;
    }
    
    class Node {
        String word;
        int count;
        public Node(String word, int count){
            this.word = word;
            this.count = count;
        }
    }
}
```

|   |   |
|---|---|
|í…ŒìŠ¤íŠ¸ 1 ã€‰|í†µê³¼ (0.38ms, 77.6MB)|
|í…ŒìŠ¤íŠ¸ 2 ã€‰|í†µê³¼ (0.29ms, 71.1MB)|
|í…ŒìŠ¤íŠ¸ 3 ã€‰|í†µê³¼ (0.56ms, 73.1MB)|
|í…ŒìŠ¤íŠ¸ 4 ã€‰|í†µê³¼ (0.41ms, 76.1MB)|
|í…ŒìŠ¤íŠ¸ 5 ã€‰|í†µê³¼ (0.25ms, 74.9MB)|

