## [ğŸƒâ€â™‚ï¸](https://school.programmers.co.kr/learn/courses/30/lessons/159993) [pg159993] ë¯¸ë¡œ íƒˆì¶œ

> **ì†Œìš” ì‹œê°„: 19ë¶„<br>
> ë©”ëª¨ë¦¬: --KB<br>
> ì‹œê°„: --ms**
## ë¬¸ì œ ì ‘ê·¼
- bfsë¥¼ 2ë²ˆ(ì‹œì‘->ë ˆë²„, ë ˆë²„->ë„ì°©) ì§„í–‰í•´ì•¼í•˜ë¯€ë¡œ í•¨ìˆ˜ë¡œ ì¬í™œìš©!!
## ë¬¸ì œ í’€ì´

1. ì‹œì‘, ë„ì°©, ë ˆë²„ ìœ„ì¹˜ë¥¼ ë³€ìˆ˜ë¡œ ì €ì¥í•˜ê³ , ë²½ê³¼ í†µë¡œëŠ” `map`ì—ì„œ `boolean`í˜•íƒœë¡œ ì €ì¥í•œë‹¤.
2. `bfs`í•¨ìˆ˜ë¥¼ í†µí•´ì„œ ì‹œì‘ì—ì„œ ë ˆë²„ê¹Œì§€ ê°€ëŠ”ë° ìµœì†Œì‹œê°„, ë ˆë²„ì—ì„œ ë„ì°©ê¹Œì§€ ê°€ëŠ”ë° ìµœì†Œì‹œê°„ì„ êµ¬í•œë‹¤.
3. ë‘˜ ì¤‘ì— ìµœì†Œì‹œê°„ì´ -1ì´ ë˜ëŠ” ê²½ìš°ëŠ” -1ë¥¼ ë°˜í™˜í•˜ê³  ì•„ë‹Œê²½ìš° ë‘ ì‹œê°„ì„ ë”í•´ì„œ ë°˜í™˜í•œë‹¤.
## ì „ì²´ ì½”ë“œ

```java
import java.util.Queue;
import java.util.LinkedList;

class Solution {
    static final int[] di = {-1,0,1,0};
    static final int[] dj = {0,1,0,-1};
    
    boolean[][] map;
    int N, M;
    
    public int solution(String[] maps) {
        N = maps.length;
        M = maps[0].length();
        map = new boolean[N][M];
        int Si=0,Sj=0,Ei=0,Ej=0,Li=0,Lj=0;
        for(int i=0; i<N; i++){
            for(int j=0; j<M; j++){
                if(maps[i].charAt(j)!='X'){
                    map[i][j]=true;
                    if(maps[i].charAt(j)=='S'){
                        Si = i;
                        Sj = j;
                    }else if(maps[i].charAt(j)=='E'){
                        Ei = i;
                        Ej = j;
                    }else if(maps[i].charAt(j)=='L'){
                        Li = i;
                        Lj = j;
                    }
                }
            
            }
        }
        int SL = bfs(Si,Sj,Li,Lj);
        if(SL == -1) return -1;
        int LE = bfs(Li,Lj,Ei,Ej);
        if(LE == -1) return -1;
        return SL+LE;
    }
    
    int bfs(final int si, final int sj, final int ei, final int ej){
        Queue<int[]> queue = new LinkedList<>();
        boolean[][] visited = new boolean[N][M];
        queue.offer(new int[]{si,sj,0});
        visited[si][sj] = true;
        while(!queue.isEmpty()){
            int[] node = queue.poll();
            
            for(int z=0; z<4; z++){
                int ni = node[0]+di[z];
                int nj = node[1]+dj[z];
                if(check(ni,nj) && map[ni][nj] && !visited[ni][nj]){
                    if(ni==ei && nj==ej) return node[2]+1;
                    queue.offer(new int[]{ni,nj,node[2]+1});
                    visited[ni][nj] = true;
                }
            }
            
        }
        return -1;    
    }
    
    boolean check(int i, int j){
        return i >= 0 && i < N && j >= 0 && j < M;
    }
}
```
