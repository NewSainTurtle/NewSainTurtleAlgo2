### PG1159993 ë¯¸ë¡œíƒˆì¶œ

[ğŸ“ë¬¸ì œë³´ê¸°](https://school.programmers.co.kr/learn/courses/30/lessons/159993)

---

#### ë¬¸ì œ í’€ì´

* BFSë¡œ í’€ìŒ
* ë ˆë²„ë¡œ ê°€ëŠ”ë° ê±¸ë¦¬ëŠ” ì‹œê°„ + ë ìœ„ì¹˜ê¹Œì§€ ê°€ëŠ”ë° ê±¸ë¦¬ëŠ” ì‹œê°„ì„ ê°ê° BFSë¡œ êµ¬í•˜ê³  ê·¸ í•©ì„ ë¦¬í„´í•¨
* BFSë¡œ ì´ë™ì„ ëª» í•œë‹¤ë©´ -1ì„ ë¦¬í„´
---

#### ì „ì²´ ì½”ë“œ

```java
import java.io.*;
import java.util.*;

class Solution {
    static int[] dy = {-1,0,1,0}, dx = {0,1,0,-1};
    static int N,M;
    static char[][] map;
    
    static class Pos {
        int y,x,sec;
        Pos(int y,int x, int sec){
            this.y=y;
            this.x=x;
            this.sec=sec;
        }
    }
    
    public int solution(String[] maps) {
        N = maps.length;
        M = maps[0].length();
        map = new char[N][M];
        int[] start_pos =new int[2];
        int[] lever_pos =new int[2];
        
        for(int i =0;i<N;i++){
            for(int j=0;j<M;j++){
                map[i][j] = maps[i].charAt(j);
                if(map[i][j]=='S') start_pos = new int[]{i,j};
                else if(map[i][j]=='L') lever_pos = new int[]{i,j};
            }
        }
        
        int lever = BFS(start_pos[0],start_pos[1],'L'); // ë ˆë²„ ìœ„ì¹˜ê¹Œì§€
        if(lever==-1) return -1;
        
        int end = BFS(lever_pos[0],lever_pos[1],'E'); // ë ìœ„ì¹˜ê¹Œì§€
        if(end==-1) return -1;

        return lever+end;
    }
    
    private static int BFS(int s_y,int s_x, char end) {
        Queue<Pos> que = new LinkedList<>();
        boolean[][] visited = new boolean[N][M];
        que.add(new Pos(s_y, s_x, 0));
        visited[s_y][s_x] = true;
        
        while (!que.isEmpty()) {
            Pos pos = que.poll();

            for(int d = 0; d < 4; d++) {
                int ny = pos.y + dy[d];
                int nx = pos.x + dx[d];
                
                if (ny < 0 || ny >= N || nx < 0 || nx >= M || visited[ny][nx] || map[ny][nx]=='X') continue;

                if(map[ny][nx]==end){
                    return pos.sec+1;
                } else {
                    visited[ny][nx] = true;
                    que.add(new Pos(ny, nx, pos.sec+1));
                }
            }
        }
        
        return -1;
    }
}
```
